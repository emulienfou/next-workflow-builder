#!/usr/bin/env tsx

/**
 * Plugin Auto-Discovery Script
 *
 * Automatically discovers all plugins in the plugins/ directory and generates
 * the plugins/index.ts file with imports. Also updates the README.md with
 * the current list of available actions.
 *
 * Additionally generates codegen templates from step files that have
 * a stepHandler function.
 *
 * Run this script:
 * - Manually: pnpm discover-plugins
 * - Automatically: Before build (in package.json)
 */

import { existsSync, mkdirSync, readdirSync, readFileSync, statSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { pathToFileURL } from "node:url";
import ts from "typescript";

/**
 * Import from local source (for development) or the installed package (for published consumers).
 * Local source is tried first because dist/ may not exist during development.
 */
async function importPackageOrLocal(localRelPath: string): Promise<Record<string, unknown>> {
  const localPath = join(import.meta.dirname, "..", "plugins", localRelPath);
  if (existsSync(localPath)) {
    return await import(pathToFileURL(localPath).href);
  }
  return await import("next-workflow-builder/plugins");
}

/**
 * Import each discovered plugin directly to populate the registry.
 * We import the individual plugin index files rather than the generated
 * plugins/index.ts because the generated file re-exports from the package
 * which may not resolve during development (dist/ not built yet).
 */
async function importConsumerPlugins(plugins: string[]): Promise<void> {
  for (const plugin of plugins) {
    const pluginIndex = join(PLUGINS_DIR, plugin, "index.ts");
    if (existsSync(pluginIndex)) {
      await import(pathToFileURL(pluginIndex).href);
    }
  }
}

const PLUGINS_DIR = join(process.cwd(), "plugins");
const OUTPUT_FILE = join(PLUGINS_DIR, "index.ts");
const CODEGEN_REGISTRY_FILE = join(process.cwd(), "lib", "codegen-registry.ts");
const README_FILE = join(process.cwd(), "README.md");
const PLUGINS_MARKER_REGEX =
  /<!-- PLUGINS:START[^>]*-->[\s\S]*?<!-- PLUGINS:END -->/;

// Regex patterns for codegen template generation
const LEADING_WHITESPACE_PATTERN = /^\s*/;

/**
 * Format TypeScript code using Prettier
 */
async function formatCode(code: string): Promise<string> {
  try {
    const prettier = await import("prettier");
    return await prettier.format(code, { parser: "typescript" });
  } catch (error) {
    console.warn("   Warning: Failed to format generated code:", error);
    return code;
  }
}

// Track generated codegen templates
const generatedCodegenTemplates = new Map<
  string,
  { template: string; integrationType: string }
>();

/**
 * Discover all plugin directories
 */
function discoverPlugins(): string[] {
  const entries = readdirSync(PLUGINS_DIR);

  const plugins = entries.filter((entry) => {
    // Skip special directories and files
    if (
      entry.startsWith("_") ||
      entry.startsWith(".") ||
      entry === "index.ts" ||
      entry === "registry.ts"
    ) {
      return false;
    }

    // Only include directories
    const fullPath = join(PLUGINS_DIR, entry);
    try {
      return statSync(fullPath).isDirectory();
    } catch {
      return false;
    }
  });

  return plugins.sort();
}

/**
 * Generate the plugins/index.ts file
 */
function generateIndexFile(plugins: string[]): void {
  const imports = plugins.map((plugin) => `import "./${ plugin }";`).join("\n");

  const content = `/**
 * Plugins Index (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * To add a new integration:
 * 1. Create a new directory in plugins/ (e.g., plugins/my-integration/)
 * 2. Add your plugin files (index.tsx, steps/, codegen/, etc.)
 * 3. Run: pnpm discover-plugins (or it runs automatically on build)
 *
 * To remove an integration:
 * 1. Delete the plugin directory
 * 2. Run: pnpm discover-plugins (or it runs automatically on build)
 */

${ imports || "// No plugins discovered" }

export {};

`;

  writeFileSync(OUTPUT_FILE, content, "utf-8");
}

/**
 * Ensure plugins/index.ts is listed in the consumer's .gitignore
 * (it's auto-generated and should not be committed).
 */
function ensureGitignore(): void {
  const gitignorePath = join(process.cwd(), ".gitignore");
  const entry = "plugins/index.ts";

  if (existsSync(gitignorePath)) {
    const content = readFileSync(gitignorePath, "utf-8");
    if (content.split("\n").some((line) => line.trim() === entry)) {
      return;
    }
    writeFileSync(gitignorePath, content.trimEnd() + `\n${ entry }\n`, "utf-8");
  } else {
    writeFileSync(gitignorePath, `${ entry }\n`, "utf-8");
  }
  console.log("Updated .gitignore with \"plugins/index.ts\"");
}

/**
 * Update the README.md with the current list of actions
 */
async function updateReadme(): Promise<void> {
  // Import the registry utilities (registry is already populated by importConsumerPlugins in main)
  const { getAllIntegrations } = await importPackageOrLocal("registry.ts") as {
    getAllIntegrations: () => { label: string; actions: { label: string }[] }[]
  };

  const integrations = getAllIntegrations();

  if (integrations.length === 0) {
    console.log("No integrations found, skipping README update");
    return;
  }

  // Generate markdown list grouped by integration
  const actionsList = integrations
    .map((integration) => {
      const actionLabels = integration.actions.map((a) => a.label).join(", ");
      return `- **${ integration.label }**: ${ actionLabels }`;
    })
    .join("\n");

  // Read current README
  const readme = readFileSync(README_FILE, "utf-8");

  // Check if markers exist
  if (!readme.includes("<!-- PLUGINS:START")) {
    console.log("README markers not found, skipping README update");
    return;
  }

  // Replace content between markers
  const updated = readme.replace(
    PLUGINS_MARKER_REGEX,
    `<!-- PLUGINS:START - Do not remove. Auto-generated by discover-plugins -->\n${ actionsList }\n<!-- PLUGINS:END -->`,
  );

  writeFileSync(README_FILE, updated, "utf-8");
  console.log(`Updated README.md with ${ integrations.length } integration(s)`);
}

// ============================================================================
// Codegen Template Generation
// ============================================================================

/** Analysis result type for step file parsing */
type StepFileAnalysis = {
  hasExportCore: boolean;
  integrationType: string | null;
  coreFunction: {
    name: string;
    params: string;
    returnType: string;
    body: string;
  } | null;
  inputTypes: string[];
  imports: string[];
};

/** Create empty analysis result */
function createEmptyAnalysis(): StepFileAnalysis {
  return {
    hasExportCore: false,
    integrationType: null,
    coreFunction: null,
    inputTypes: [],
    imports: [],
  };
}

/** Process exported variable declarations */
function processExportedVariable(
  decl: ts.VariableDeclaration,
  result: StepFileAnalysis,
): void {
  if (!ts.isIdentifier(decl.name)) {
    return;
  }

  const name = decl.name.text;
  const init = decl.initializer;

  if (name === "_integrationType" && init && ts.isStringLiteral(init)) {
    result.integrationType = init.text;
  }
}

/** Check if a type name should be included in exports */
function shouldIncludeType(typeName: string): boolean {
  return (
    typeName.endsWith("Result") ||
    typeName.endsWith("Credentials") ||
    typeName.endsWith("CoreInput")
  );
}

/** Check if an import should be included in exports */
function shouldIncludeImport(moduleSpec: string, importText: string): boolean {
  // Skip internal imports
  if (moduleSpec.startsWith("@/") || moduleSpec.startsWith(".")) {
    return false;
  }

  return !importText.includes("server-only");
}

/** Extract function info from a function declaration */
function extractFunctionInfo(
  node: ts.FunctionDeclaration,
  sourceCode: string,
): StepFileAnalysis["coreFunction"] {
  if (!(node.name && node.body)) {
    return null;
  }

  const params = node.parameters
    .map((p) => sourceCode.slice(p.pos, p.end).trim())
    .join(", ");

  const returnType = node.type
    ? sourceCode.slice(node.type.pos, node.type.end).trim()
    : "Promise<unknown>";

  const body = sourceCode.slice(node.body.pos, node.body.end).trim();

  return {
    name: node.name.text,
    params,
    returnType,
    body,
  };
}

/** Process variable statement node */
function processVariableStatement(
  node: ts.VariableStatement,
  result: StepFileAnalysis,
): void {
  const isExported = node.modifiers?.some(
    (m) => m.kind === ts.SyntaxKind.ExportKeyword,
  );
  if (!isExported) {
    return;
  }

  for (const decl of node.declarationList.declarations) {
    processExportedVariable(decl, result);
  }
}

/** Process type alias node */
function processTypeAlias(
  node: ts.TypeAliasDeclaration,
  sourceCode: string,
  result: StepFileAnalysis,
): void {
  if (shouldIncludeType(node.name.text)) {
    result.inputTypes.push(sourceCode.slice(node.pos, node.end).trim());
  }
}

/** Process import declaration node */
function processImportDeclaration(
  node: ts.ImportDeclaration,
  sourceCode: string,
  result: StepFileAnalysis,
): void {
  const spec = node.moduleSpecifier;
  if (!ts.isStringLiteral(spec)) {
    return;
  }
  const importText = sourceCode.slice(node.pos, node.end).trim();
  if (shouldIncludeImport(spec.text, importText)) {
    result.imports.push(importText);
  }
}

/** Process a single AST node for exports, types, and imports */
function processNode(
  node: ts.Node,
  sourceCode: string,
  result: StepFileAnalysis,
): void {
  if (ts.isVariableStatement(node)) {
    processVariableStatement(node, result);
    return;
  }

  if (ts.isTypeAliasDeclaration(node)) {
    processTypeAlias(node, sourceCode, result);
    return;
  }

  if (ts.isImportDeclaration(node)) {
    processImportDeclaration(node, sourceCode, result);
    return;
  }

  // Check for stepHandler function (doesn't need to be exported)
  if (ts.isFunctionDeclaration(node) && node.name?.text === "stepHandler") {
    result.hasExportCore = true;
    result.coreFunction = extractFunctionInfo(node, sourceCode);
  }
}

/**
 * Extract information about a step file's exports using TypeScript AST
 */
function analyzeStepFile(filePath: string): StepFileAnalysis {
  const result = createEmptyAnalysis();

  if (!existsSync(filePath)) {
    return result;
  }

  const sourceCode = readFileSync(filePath, "utf-8");
  const sourceFile = ts.createSourceFile(
    filePath,
    sourceCode,
    ts.ScriptTarget.Latest,
    true,
  );

  // Single pass: find stepHandler function, types, and imports
  ts.forEachChild(sourceFile, (node) => {
    processNode(node, sourceCode, result);
  });

  return result;
}

/**
 * Generate a codegen template from a step file's core function
 */
async function generateCodegenTemplate(
  stepFilePath: string,
  stepFunctionName: string,
): Promise<string | null> {
  const analysis = analyzeStepFile(stepFilePath);

  if (!(analysis.hasExportCore && analysis.coreFunction)) {
    return null;
  }

  const { coreFunction, integrationType, inputTypes, imports } = analysis;

  // Extract the inner body (remove outer braces)
  let innerBody = coreFunction.body.trim();
  if (innerBody.startsWith("{")) {
    innerBody = innerBody.slice(1);
  }
  if (innerBody.endsWith("}")) {
    innerBody = innerBody.slice(0, -1);
  }
  innerBody = innerBody.trim();

  // Extract input type from first parameter
  const inputType =
    coreFunction.params
      .split(",")[0]
      .replace(LEADING_WHITESPACE_PATTERN, "")
      .split(":")[1]
      ?.trim() || "unknown";

  // Build the raw template (formatter will fix indentation)
  const rawTemplate = `${ imports.join("\n") }
import { fetchCredentials } from './lib/credential-helper';

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

${ inputTypes.join("\n\n") }

export async function ${ stepFunctionName }(input: ${ inputType }): ${ coreFunction.returnType } {
  "use step";
  const credentials = await fetchCredentials("${ integrationType || "unknown" }");
${ innerBody }
}`;

  // Format the generated code
  return await formatCode(rawTemplate);
}

/**
 * Process step files and generate codegen templates
 */
async function processStepFilesForCodegen(): Promise<void> {
  const { getAllIntegrations, computeActionId } = await importPackageOrLocal("registry.ts") as {
    getAllIntegrations: () => {
      type: string;
      actions: { stepImportPath: string; stepFunction: string; slug: string }[]
    }[];
    computeActionId: (type: string, slug: string) => string;
  };
  const integrations = getAllIntegrations();

  for (const integration of integrations) {
    for (const action of integration.actions) {
      const stepFilePath = join(
        PLUGINS_DIR,
        integration.type,
        "steps",
        `${ action.stepImportPath }.ts`,
      );

      const template = await generateCodegenTemplate(
        stepFilePath,
        action.stepFunction,
      );

      if (template) {
        const actionId = computeActionId(integration.type, action.slug);
        generatedCodegenTemplates.set(actionId, {
          template,
          integrationType: integration.type,
        });
        console.log(`   Generated codegen template for ${ actionId }`);
      }
    }
  }
}

/**
 * Generate the lib/codegen-registry.ts file with auto-generated templates
 */
function generateCodegenRegistry(): void {
  const entries = Array.from(generatedCodegenTemplates.entries());

  if (entries.length === 0) {
    console.log("No codegen templates generated");
    return;
  }

  // Generate template string literals
  const templateEntries = entries
    .map(([actionId, { template }]) => {
      // Escape backticks and ${} in the template for safe embedding
      const escapedTemplate = template
        .replace(/\\/g, "\\\\")
        .replace(/`/g, "\\`")
        .replace(/\$\{/g, "\\${");
      return `  "${ actionId }": \`${ escapedTemplate }\`,`;
    })
    .join("\n\n");

  const content = `/**
 * Codegen Registry (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * Contains auto-generated codegen templates for steps with stepHandler.
 * These templates are used when exporting workflows to standalone projects.
 *
 * Generated templates: ${ entries.length }
 */

/**
 * Auto-generated codegen templates
 * Maps action IDs to their generated export code templates
 */
export const AUTO_GENERATED_TEMPLATES: Record<string, string> = {
${ templateEntries }
};

/**
 * Get the auto-generated codegen template for an action
 */
export function getAutoGeneratedTemplate(actionId: string): string | undefined {
  return AUTO_GENERATED_TEMPLATES[actionId];
}
`;

  writeFileSync(CODEGEN_REGISTRY_FILE, content, "utf-8");
  console.log(
    `Generated lib/codegen-registry.ts with ${ entries.length } template(s)`,
  );
}

/**
 * Main execution
 */
async function main(): Promise<void> {
  // Ensure plugins directory exists
  if (!existsSync(PLUGINS_DIR)) {
    mkdirSync(PLUGINS_DIR, { recursive: true });
  }

  console.log("Discovering plugins...");

  const plugins = discoverPlugins();

  if (plugins.length === 0) {
    console.log("No plugins found in plugins/ directory");
  } else {
    console.log(`Found ${ plugins.length } plugin(s):`);
    for (const plugin of plugins) {
      console.log(`   - ${ plugin }`);
    }
  }

  console.log("\nGenerating plugins/index.ts...");
  generateIndexFile(plugins);
  ensureGitignore();

  // Import each plugin directly to populate the registry before generation steps
  await importConsumerPlugins(plugins);

  console.log("Updating README.md...");
  await updateReadme();

  console.log("\nProcessing step files for codegen templates...");
  await processStepFilesForCodegen();

  console.log("Generating lib/codegen-registry.ts...");
  generateCodegenRegistry();

  console.log("Done! Plugin registry updated.\n");
}

main().catch((error) => {
  console.error("Error:", error);
  process.exit(1);
});
