import fs from 'node:fs';
import path from 'node:path';

const MARKER = '/* AUTO-GENERATED BY next-workflow-builder — do not edit */';

function buildRouteTemplate(dbImportPath: string, authImportPath: string): string {
  return `${MARKER}
import { createWorkflowApiHandler } from 'next-workflow-builder';
import { db } from '${dbImportPath}';
import { auth } from '${authImportPath}';

const handler = createWorkflowApiHandler({ db, auth });

export { handler as GET, handler as POST, handler as PUT, handler as DELETE, handler as PATCH, handler as OPTIONS };
`;
}

/**
 * Detect whether the consumer uses `src/app/` or `app/`.
 * Returns the absolute path to the `app` directory, or `null` if neither exists.
 */
export function resolveAppDir(projectDir: string): string | null {
  const srcApp = path.join(projectDir, 'src', 'app');
  if (fs.existsSync(srcApp)) return srcApp;

  const app = path.join(projectDir, 'app');
  if (fs.existsSync(app)) return app;

  return null;
}

/**
 * Convert an API route like `/api/workflow` to a filesystem path segment
 * with an optional catch-all slug: `api/workflow/[[...slug]]`
 */
export function apiRouteToFsPath(apiRoute: string): string {
  const stripped = apiRoute.replace(/^\/+|\/+$/g, '');
  return path.join(stripped, '[[...slug]]');
}

export interface GenerateApiRouteOptions {
  /** Absolute path to the project root (where next.config.ts lives) */
  projectDir?: string;
  /** The API route prefix. Default: '/api/workflow' */
  apiRoute?: string;
  /** Import path for the database module. Default: '@/lib/db' */
  dbImportPath?: string;
  /** Import path for the auth module. Default: '@/lib/auth' */
  authImportPath?: string;
}

/**
 * Write the catch-all API route handler to disk.
 *
 * Safety rules:
 * - If the file exists **with** the marker comment → overwrite (safe to regenerate)
 * - If the file exists **without** the marker → skip (user has a custom file)
 * - If no `app/` directory is found → warn and skip
 * - Appends the generated path to `.gitignore` if not already present
 */
export function generateApiRoute(options: GenerateApiRouteOptions = {}): void {
  const projectDir = options.projectDir ?? process.cwd();
  const apiRoute = options.apiRoute ?? '/api/workflow';
  const dbImportPath = options.dbImportPath ?? '@/lib/db';
  const authImportPath = options.authImportPath ?? '@/lib/auth';

  const appDir = resolveAppDir(projectDir);
  if (!appDir) {
    console.warn(
      '[next-workflow-builder] Could not find app/ or src/app/ directory. Skipping API route generation.',
    );
    return;
  }

  const relativeSegment = apiRouteToFsPath(apiRoute);
  const routeDir = path.join(appDir, relativeSegment);
  const routeFile = path.join(routeDir, 'route.ts');

  // If the file already exists, check for the marker
  if (fs.existsSync(routeFile)) {
    const existing = fs.readFileSync(routeFile, 'utf-8');
    if (!existing.includes(MARKER)) {
      // User has a custom implementation — do not overwrite
      return;
    }
  }

  fs.mkdirSync(routeDir, { recursive: true });
  fs.writeFileSync(routeFile, buildRouteTemplate(dbImportPath, authImportPath));

  updateGitignore(projectDir, appDir, relativeSegment);
}

/**
 * Ensure the generated route path is listed in the project's `.gitignore`.
 */
function updateGitignore(
  projectDir: string,
  appDir: string,
  relativeSegment: string,
): void {
  const gitignorePath = path.join(projectDir, '.gitignore');

  // Build the ignore entry relative to the project root
  const appRelative = path.relative(projectDir, appDir);
  const entry = path.join(appRelative, relativeSegment, 'route.ts')
    .replace(/\[/g, '\\[')
    .replace(/]/g, '\\]');

  let content = '';
  if (fs.existsSync(gitignorePath)) {
    content = fs.readFileSync(gitignorePath, 'utf-8');
    if (content.includes(entry)) return;
  }

  const section = `\n# Auto-generated workflow API route\n${entry}\n`;
  fs.writeFileSync(gitignorePath, content + section);
}
