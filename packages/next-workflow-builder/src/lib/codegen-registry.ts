/**
 * Codegen Registry (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * Contains auto-generated codegen templates for steps with stepHandler.
 * These templates are used when exporting workflows to standalone projects.
 *
 * Generated templates: 40
 */

/**
 * Auto-generated codegen templates
 * Maps action IDs to their generated export code templates
 */
export const AUTO_GENERATED_TEMPLATES: Record<string, string> = {
  "ai-gateway/generate-text": `import { createGateway, generateObject, generateText } from "ai";
import { z } from "zod";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GenerateTextResult =
  | { success: true; text: string }
  | { success: true; object: Record<string, unknown> }
  | { success: false; error: string };

export type GenerateTextCoreInput = {
  aiModel?: string;
  aiPrompt?: string;
  aiFormat?: string;
  aiSchema?: string;
};

export async function generateTextStep(
  input: GenerateTextCoreInput,
): Promise<GenerateTextResult> {
  "use step";
  const credentials = await fetchCredentials("ai-gateway");
  const apiKey = credentials.AI_GATEWAY_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "AI_GATEWAY_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  const modelId = input.aiModel || "meta/llama-4-scout";
  const promptText = input.aiPrompt || "";

  if (!promptText || promptText.trim() === "") {
    return {
      success: false,
      error: "Prompt is required for text generation",
    };
  }

  const modelString = getModelString(modelId);

  try {
    const gateway = createGateway({
      apiKey,
    });

    if (input.aiFormat === "object" && input.aiSchema) {
      const schema = JSON.parse(input.aiSchema) as SchemaField[];
      const zodSchema = buildZodSchema(schema);

      const { object } = await generateObject({
        model: gateway(modelString),
        prompt: promptText,
        schema: zodSchema,
      });

      return { success: true, object };
    }

    const { text } = await generateText({
      model: gateway(modelString),
      prompt: promptText,
    });

    return { success: true, text };
  } catch (error) {
    const message = await getErrorMessageAsync(error);
    return {
      success: false,
      error: \`Text generation failed: \${message}\`,
    };
  }
}
`,

  "ai-gateway/generate-image": `import { createGateway, experimental_generateImage as generateImage } from "ai";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GenerateImageResult =
  | { success: true; base64: string }
  | { success: false; error: string };

export type GenerateImageCoreInput = {
  imageModel?: string;
  imagePrompt?: string;
};

export async function generateImageStep(
  input: GenerateImageCoreInput,
): Promise<GenerateImageResult> {
  "use step";
  const credentials = await fetchCredentials("ai-gateway");
  const apiKey = credentials.AI_GATEWAY_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "AI_GATEWAY_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  const modelId = input.imageModel || "google/imagen-4.0-generate-001";
  const promptText = input.imagePrompt || "";

  if (!promptText || promptText.trim() === "") {
    return {
      success: false,
      error: "Prompt is required for image generation",
    };
  }

  try {
    const gateway = createGateway({
      apiKey,
    });
    const result = await generateImage({
      // biome-ignore lint/suspicious/noExplicitAny: AI gateway model ID is dynamic
      model: gateway.imageModel(modelId as any),
      prompt: promptText,
      size: "1024x1024",
    });

    if (!result.image) {
      return {
        success: false,
        error: "Failed to generate image: No image returned",
      };
    }

    const base64 = result.image.base64;

    return { success: true, base64 };
  } catch (error) {
    const message = await getErrorMessageAsync(error);
    return {
      success: false,
      error: \`Image generation failed: \${message}\`,
    };
  }
}
`,

  "blob/put": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type PutBlobResult =
  | { success: true; url: string; downloadUrl: string; pathname: string }
  | { success: false; error: string };

export type PutBlobCoreInput = {
  pathname: string;
  body: string;
  contentType?: string;
  access?: string;
  addRandomSuffix?: string;
};

export async function putBlobStep(
  input: PutBlobCoreInput,
): Promise<PutBlobResult> {
  "use step";
  const credentials = await fetchCredentials("blob");
  const token = credentials.BLOB_READ_WRITE_TOKEN;

  if (!token) {
    return {
      success: false,
      error:
        "BLOB_READ_WRITE_TOKEN is not configured. Please add it in Project Integrations.",
    };
  }

  if (!input.pathname) {
    return {
      success: false,
      error: "Pathname is required",
    };
  }

  if (!input.body) {
    return {
      success: false,
      error: "Content body is required",
    };
  }

  try {
    const url = new URL(\`/\${input.pathname}\`, BLOB_API_URL);

    // Add query parameters
    const addRandomSuffix = input.addRandomSuffix !== "false";
    if (!addRandomSuffix) {
      url.searchParams.set("addRandomSuffix", "false");
    }

    const headers: Record<string, string> = {
      Authorization: \`Bearer \${token}\`,
      "x-api-version": "7",
    };

    if (input.contentType) {
      headers["x-content-type"] = input.contentType;
    }

    const response = await fetch(url.toString(), {
      method: "PUT",
      headers,
      body: input.body,
    });

    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage: string;
      try {
        const errorData = JSON.parse(errorText);
        errorMessage = errorData.error?.message || errorText;
      } catch {
        errorMessage = errorText || \`HTTP \${response.status}\`;
      }
      return {
        success: false,
        error: errorMessage,
      };
    }

    const data = (await response.json()) as PutBlobResponse;
    return {
      success: true,
      url: data.url,
      downloadUrl: data.downloadUrl,
      pathname: data.pathname,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to upload blob: \${message}\`,
    };
  }
}
`,

  "blob/list": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ListBlobsResult =
  | {
      success: true;
      blobs: BlobItem[];
      cursor?: string;
      hasMore: boolean;
    }
  | { success: false; error: string };

export type ListBlobsCoreInput = {
  prefix?: string;
  limit?: number;
  cursor?: string;
};

export async function listBlobsStep(
  input: ListBlobsCoreInput,
): Promise<ListBlobsResult> {
  "use step";
  const credentials = await fetchCredentials("blob");
  const token = credentials.BLOB_READ_WRITE_TOKEN;

  if (!token) {
    return {
      success: false,
      error:
        "BLOB_READ_WRITE_TOKEN is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const url = new URL(BLOB_API_URL);

    if (input.prefix) {
      url.searchParams.set("prefix", input.prefix);
    }

    if (input.limit) {
      url.searchParams.set("limit", String(input.limit));
    }

    if (input.cursor) {
      url.searchParams.set("cursor", input.cursor);
    }

    const response = await fetch(url.toString(), {
      method: "GET",
      headers: {
        Authorization: \`Bearer \${token}\`,
        "x-api-version": "7",
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage: string;
      try {
        const errorData = JSON.parse(errorText);
        errorMessage = errorData.error?.message || errorText;
      } catch {
        errorMessage = errorText || \`HTTP \${response.status}\`;
      }
      return {
        success: false,
        error: errorMessage,
      };
    }

    const data = (await response.json()) as ListBlobsResponse;
    return {
      success: true,
      blobs: data.blobs,
      cursor: data.cursor,
      hasMore: data.hasMore,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to list blobs: \${message}\`,
    };
  }
}
`,

  "clerk/get-user": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

export type ClerkGetUserCoreInput = {
  userId: string;
};

export async function clerkGetUserStep(
  input: ClerkGetUserCoreInput,
): Promise<ClerkUserResult> {
  "use step";
  const credentials = await fetchCredentials("clerk");
  const secretKey = credentials.CLERK_SECRET_KEY;

  if (!secretKey) {
    return {
      success: false,
      error: {
        message:
          "CLERK_SECRET_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  if (!input.userId) {
    return {
      success: false,
      error: { message: "User ID is required." },
    };
  }

  try {
    const response = await fetch(
      \`https://api.clerk.com/v1/users/\${encodeURIComponent(input.userId)}\`,
      {
        headers: {
          Authorization: \`Bearer \${secretKey}\`,
          "Content-Type": "application/json",
          "User-Agent": "workflow-builder.dev",
        },
      },
    );

    if (!response.ok) {
      const errorBody = await response.json().catch(() => ({}));
      return {
        success: false,
        error: {
          message:
            errorBody.errors?.[0]?.message ||
            \`Failed to get user: \${response.status}\`,
        },
      };
    }

    const apiUser = await response.json();
    return { success: true, data: toClerkUserData(apiUser) };
  } catch (err) {
    return {
      success: false,
      error: { message: \`Failed to get user: \${getErrorMessage(err)}\` },
    };
  }
}
`,

  "clerk/create-user": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

export type ClerkCreateUserCoreInput = {
  emailAddress: string;
  firstName?: string;
  lastName?: string;
  password?: string;
  publicMetadata?: string;
  privateMetadata?: string;
};

export async function clerkCreateUserStep(
  input: ClerkCreateUserCoreInput,
): Promise<ClerkUserResult> {
  "use step";
  const credentials = await fetchCredentials("clerk");
  const secretKey = credentials.CLERK_SECRET_KEY;

  if (!secretKey) {
    return {
      success: false,
      error: {
        message:
          "CLERK_SECRET_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  if (!input.emailAddress) {
    return {
      success: false,
      error: { message: "Email address is required." },
    };
  }

  try {
    // Build the request body
    const body: Record<string, unknown> = {
      email_address: [input.emailAddress],
    };

    if (input.firstName) {
      body.first_name = input.firstName;
    }
    if (input.lastName) {
      body.last_name = input.lastName;
    }
    if (input.password) {
      body.password = input.password;
    }
    if (input.publicMetadata) {
      try {
        body.public_metadata = JSON.parse(input.publicMetadata);
      } catch {
        return {
          success: false,
          error: { message: "Invalid JSON format for publicMetadata" },
        };
      }
    }
    if (input.privateMetadata) {
      try {
        body.private_metadata = JSON.parse(input.privateMetadata);
      } catch {
        return {
          success: false,
          error: { message: "Invalid JSON format for privateMetadata" },
        };
      }
    }

    const response = await fetch("https://api.clerk.com/v1/users", {
      method: "POST",
      headers: {
        Authorization: \`Bearer \${secretKey}\`,
        "Content-Type": "application/json",
        "User-Agent": "workflow-builder.dev",
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorBody = await response.json().catch(() => ({}));
      return {
        success: false,
        error: {
          message:
            errorBody.errors?.[0]?.message ||
            \`Failed to create user: \${response.status}\`,
        },
      };
    }

    const apiUser = await response.json();
    return { success: true, data: toClerkUserData(apiUser) };
  } catch (err) {
    return {
      success: false,
      error: { message: \`Failed to create user: \${getErrorMessage(err)}\` },
    };
  }
}
`,

  "clerk/update-user": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

export type ClerkUpdateUserCoreInput = {
  userId: string;
  firstName?: string;
  lastName?: string;
  publicMetadata?: string;
  privateMetadata?: string;
};

export async function clerkUpdateUserStep(
  input: ClerkUpdateUserCoreInput,
): Promise<ClerkUserResult> {
  "use step";
  const credentials = await fetchCredentials("clerk");
  const secretKey = credentials.CLERK_SECRET_KEY;

  if (!secretKey) {
    return {
      success: false,
      error: {
        message:
          "CLERK_SECRET_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  if (!input.userId) {
    return {
      success: false,
      error: { message: "User ID is required." },
    };
  }

  try {
    // Build the request body
    const body: Record<string, unknown> = {};

    if (input.firstName !== undefined) {
      body.first_name = input.firstName;
    }
    if (input.lastName !== undefined) {
      body.last_name = input.lastName;
    }
    if (input.publicMetadata) {
      try {
        body.public_metadata = JSON.parse(input.publicMetadata);
      } catch {
        return {
          success: false,
          error: { message: "Invalid JSON format for publicMetadata" },
        };
      }
    }
    if (input.privateMetadata) {
      try {
        body.private_metadata = JSON.parse(input.privateMetadata);
      } catch {
        return {
          success: false,
          error: { message: "Invalid JSON format for privateMetadata" },
        };
      }
    }

    const response = await fetch(
      \`https://api.clerk.com/v1/users/\${encodeURIComponent(input.userId)}\`,
      {
        method: "PATCH",
        headers: {
          Authorization: \`Bearer \${secretKey}\`,
          "Content-Type": "application/json",
          "User-Agent": "workflow-builder.dev",
        },
        body: JSON.stringify(body),
      },
    );

    if (!response.ok) {
      const errorBody = await response.json().catch(() => ({}));
      return {
        success: false,
        error: {
          message:
            errorBody.errors?.[0]?.message ||
            \`Failed to update user: \${response.status}\`,
        },
      };
    }

    const apiUser = await response.json();
    return { success: true, data: toClerkUserData(apiUser) };
  } catch (err) {
    return {
      success: false,
      error: { message: \`Failed to update user: \${getErrorMessage(err)}\` },
    };
  }
}
`,

  "clerk/delete-user": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type DeleteUserResult =
  | { success: true; data: { deleted: true } }
  | { success: false; error: { message: string } };

export type ClerkDeleteUserCoreInput = {
  userId: string;
};

export async function clerkDeleteUserStep(
  input: ClerkDeleteUserCoreInput,
): Promise<DeleteUserResult> {
  "use step";
  const credentials = await fetchCredentials("clerk");
  const secretKey = credentials.CLERK_SECRET_KEY;

  if (!secretKey) {
    return {
      success: false,
      error: {
        message:
          "CLERK_SECRET_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  if (!input.userId) {
    return {
      success: false,
      error: { message: "User ID is required." },
    };
  }

  try {
    const response = await fetch(
      \`https://api.clerk.com/v1/users/\${encodeURIComponent(input.userId)}\`,
      {
        method: "DELETE",
        headers: {
          Authorization: \`Bearer \${secretKey}\`,
          "Content-Type": "application/json",
          "User-Agent": "workflow-builder.dev",
        },
      },
    );

    if (!response.ok) {
      const errorBody = await response.json().catch(() => ({}));
      return {
        success: false,
        error: {
          message:
            errorBody.errors?.[0]?.message ||
            \`Failed to delete user: \${response.status}\`,
        },
      };
    }

    return { success: true, data: { deleted: true } };
  } catch (err) {
    return {
      success: false,
      error: { message: \`Failed to delete user: \${getErrorMessage(err)}\` },
    };
  }
}
`,

  "facebook/import-event": `import {
  algoliaClient,
  createPerformanceFromChannel,
  findVenueByNameOrId,
  getAlgoliaIndexName,
  getFinalUrlAndDomain,
  getImageSizeType,
  insertEventWithUniqueSlug,
  uploadCover,
} from "@beatplatform/core";
import {
  Channel,
  Database,
  EventStatus,
  FileDirectory,
  db,
} from "@beatplatform/db";
import { type EventData, scrapeFbEvent } from "facebook-event-scraper";
import slugify from "slugify";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ImportEventResult =
  | { success: true; name: string; logs: string[] }
  | { success: false; error: string };

export type ImportEventCoreInput = {
  url: string;
  venueId?: string;
  artistIds?: string[];
};

export async function importEventStep(
  input: ImportEventCoreInput,
): Promise<ImportEventResult> {
  "use step";
  const credentials = await fetchCredentials("facebook-event-scraper");
  const logs: string[] = [];

  if (!input.url) {
    return { success: false, error: "Facebook event URL is required." };
  }

  try {
    // Step 1: Scrape Facebook event
    const fbData: EventData = await scrapeFbEvent(input.url);
    logs.push(\`[scraped] "\${fbData.name}"\`);

    // Step 2: Check if event already exists
    const existing = await db
      .selectFrom("SocialLink")
      .select(({ fn, cast }) =>
        cast<number>(fn.count("SocialLink.id"), "integer").as("count"),
      )
      .where("channelId", "=", fbData.id)
      .executeTakeFirst();

    if ((existing?.count || 0) > 0) {
      return {
        success: false,
        error: \`Event "\${fbData.name}" already imported.\`,
      };
    }

    // Step 3: Create event object and upload image
    const event = {
      id: crypto.randomUUID(),
      name: fbData.name,
      slug: slugify(fbData.name, { lower: true, strict: true }),
      description: fbData.description?.replace(/\\n/g, "<br />"),
      startAt: new Date(fbData.startTimestamp * 1000).toISOString(),
      endAt: fbData.endTimestamp
        ? new Date(fbData.endTimestamp * 1000).toISOString()
        : undefined,
      status: EventStatus.HAPPENING,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    } as Database["Event"];

    let image: Pick<Database["File"], "id" | "url"> | undefined;
    if (fbData.photo?.imageUri) {
      try {
        image = await uploadCover(
          [
            {
              url: fbData.photo.imageUri,
              ...(await getImageSizeType(fbData.photo.imageUri)),
            },
          ],
          FileDirectory.EVENTS,
        );
        event.imageId = image?.id;
        logs.push("[uploaded] Event image");
      } catch {
        logs.push("[warn] Event image could not be retrieved");
      }
    }

    // Step 4: Process hosts â€” create performances and find venue
    const performances = new Map<string, Database["Performance"]>();
    let venue:
      | (Pick<Database["Venue"], "id"> & Pick<Database["Location"], "country">)
      | undefined;

    for (const { id, name } of fbData.hosts) {
      await createPerformanceFromChannel(
        event,
        performances,
        id,
        Channel.FACEBOOK,
      );
      const foundVenue = await findVenueByNameOrId(input.venueId, name);
      if (foundVenue) venue = foundVenue;
    }

    logs.push(
      \`[hosts] \${performances.size} performances, venue \${venue ? "found" : "not found"}\`,
    );

    // Step 5: Index in Algolia
    const { objectID } = await algoliaClient.saveObject({
      indexName: getAlgoliaIndexName("events"),
      body: {
        id: event.id,
        slug: event.slug,
        name: event.name,
        startAt: event.startAt,
        endAt: event.endAt,
        image: image?.url,
        country: venue?.country,
      },
    });

    // Step 6: Insert event into database
    await insertEventWithUniqueSlug({
      ...event,
      venueId: venue?.id,
      algoliaObjectID: objectID!,
    });

    // Step 7: Insert social link
    await db
      .insertInto("SocialLink")
      .values({
        id: crypto.randomUUID(),
        channel: Channel.FACEBOOK,
        channelId: fbData.id,
        link: fbData.url,
        eventId: event.id,
        synchronizable: true,
      })
      .execute();

    // Step 8: Insert ticket link if available
    if (fbData.ticketUrl) {
      const { domain } = await getFinalUrlAndDomain(fbData.ticketUrl);
      await db
        .insertInto("Ticket")
        .values({
          id: crypto.randomUUID(),
          link: fbData.ticketUrl,
          eventId: event.id,
          provider: domain?.toString(),
        })
        .execute();
      logs.push(\`[ticket] \${domain}\`);
    }

    // Step 9: Insert performances
    if (performances.size > 0) {
      await db
        .insertInto("Performance")
        .values(Array.from(performances.values()))
        .execute();
    }

    // Step 10: Link manually selected artists
    const artistIds = input.artistIds
      ? input.artistIds.map((id) => id.trim()).filter(Boolean)
      : [];

    if (artistIds.length > 0) {
      const artists = await db
        .selectFrom("Artist")
        .select(["Artist.id"])
        .where("Artist.id", "in", artistIds)
        .execute();

      if (artists.length > 0) {
        await db
          .insertInto("Performance")
          .values(
            artists.map((artist) => ({
              id: crypto.randomUUID(),
              time: new Date(event.startAt).toISOString(),
              length: 0,
              eventId: event.id,
              artistId: artist.id,
            })),
          )
          .executeTakeFirstOrThrow();
        logs.push(\`[linked] \${artists.length} artists\`);
      }
    }

    // Step 11: Update venue timestamp
    if (venue?.id) {
      await db
        .updateTable("Venue")
        .set({ lastEventsUpdatedAt: new Date().toISOString() })
        .where("Venue.id", "=", venue.id)
        .executeTakeFirstOrThrow();
    }

    logs.push(\`[imported] "\${event.name}"\`);
    return { success: true, name: event.name, logs };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to import Facebook event: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "fal/generate-image": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GenerateImageResult =
  | {
      success: true;
      data: { imageUrl: string; width?: number; height?: number };
    }
  | { success: false; error: { message: string } };

export type FalGenerateImageCoreInput = {
  model: string;
  prompt: string;
  imageSize?: string;
  numImages?: number;
};

export async function falGenerateImageStep(
  input: FalGenerateImageCoreInput,
): Promise<GenerateImageResult> {
  "use step";
  const credentials = await fetchCredentials("fal");
  const apiKey = credentials.FAL_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "FAL_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  try {
    const model = input.model || "fal-ai/flux/schnell";
    const response = await fetch(\`\${FAL_API_URL}/\${model}\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Key \${apiKey}\`,
      },
      body: JSON.stringify({
        prompt: input.prompt,
        image_size: input.imageSize || "landscape_16_9",
        num_images: input.numImages || 1,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: { message: \`HTTP \${response.status}: \${errorText}\` },
      };
    }

    const queueResponse = (await response.json()) as FalQueueResponse;

    // If the response is queued, poll for the result
    let result: FalImageResponse;
    if (
      queueResponse.status === "IN_QUEUE" ||
      queueResponse.status === "IN_PROGRESS"
    ) {
      result = await pollForResult(
        queueResponse.status_url,
        queueResponse.response_url,
        apiKey,
      );
    } else {
      // Immediate response (shouldn't happen with queue endpoint, but handle it)
      result = queueResponse as unknown as FalImageResponse;
    }

    if (result.error) {
      return { success: false, error: { message: result.error } };
    }

    if (!result.images || result.images.length === 0) {
      return {
        success: false,
        error: { message: "No images returned from fal.ai" },
      };
    }

    const image = result.images[0];
    return {
      success: true,
      data: { imageUrl: image.url, width: image.width, height: image.height },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to generate image: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "fal/generate-video": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GenerateVideoResult =
  | { success: true; data: { videoUrl: string } }
  | { success: false; error: { message: string } };

export type FalGenerateVideoCoreInput = {
  model: string;
  prompt: string;
  imageUrl?: string;
};

export async function falGenerateVideoStep(
  input: FalGenerateVideoCoreInput,
): Promise<GenerateVideoResult> {
  "use step";
  const credentials = await fetchCredentials("fal");
  const apiKey = credentials.FAL_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "FAL_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  try {
    const model = input.model || "fal-ai/minimax-video";

    const requestBody: Record<string, unknown> = {
      prompt: input.prompt,
    };

    if (input.imageUrl) {
      requestBody.image_url = input.imageUrl;
    }

    const response = await fetch(\`\${FAL_API_URL}/\${model}\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Key \${apiKey}\`,
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: { message: \`HTTP \${response.status}: \${errorText}\` },
      };
    }

    const queueResponse = (await response.json()) as FalQueueResponse;

    let result: FalVideoResponse;
    if (
      queueResponse.status === "IN_QUEUE" ||
      queueResponse.status === "IN_PROGRESS"
    ) {
      result = await pollForResult(
        queueResponse.status_url,
        queueResponse.response_url,
        apiKey,
      );
    } else {
      result = queueResponse as unknown as FalVideoResponse;
    }

    if (result.error) {
      return { success: false, error: { message: result.error } };
    }

    if (!result.video?.url) {
      return {
        success: false,
        error: { message: "No video returned from fal.ai" },
      };
    }

    return { success: true, data: { videoUrl: result.video.url } };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to generate video: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "fal/upscale-image": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type UpscaleImageResult =
  | {
      success: true;
      data: { imageUrl: string; width?: number; height?: number };
    }
  | { success: false; error: { message: string } };

export type FalUpscaleImageCoreInput = {
  model: string;
  imageUrl: string;
  scale?: string;
};

export async function falUpscaleImageStep(
  input: FalUpscaleImageCoreInput,
): Promise<UpscaleImageResult> {
  "use step";
  const credentials = await fetchCredentials("fal");
  const apiKey = credentials.FAL_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "FAL_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  try {
    const model = input.model || "fal-ai/creative-upscaler";
    const scale = Number.parseInt(input.scale || "2", 10);

    const response = await fetch(\`\${FAL_API_URL}/\${model}\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Key \${apiKey}\`,
      },
      body: JSON.stringify({
        image_url: input.imageUrl,
        scale,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: { message: \`HTTP \${response.status}: \${errorText}\` },
      };
    }

    const queueResponse = (await response.json()) as FalQueueResponse;

    let result: FalUpscaleResponse;
    if (
      queueResponse.status === "IN_QUEUE" ||
      queueResponse.status === "IN_PROGRESS"
    ) {
      result = await pollForResult(
        queueResponse.status_url,
        queueResponse.response_url,
        apiKey,
      );
    } else {
      result = queueResponse as unknown as FalUpscaleResponse;
    }

    if (result.error) {
      return { success: false, error: { message: result.error } };
    }

    if (!result.image?.url) {
      return {
        success: false,
        error: { message: "No image returned from fal.ai" },
      };
    }

    return {
      success: true,
      data: {
        imageUrl: result.image.url,
        width: result.image.width,
        height: result.image.height,
      },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to upscale image: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "fal/remove-background": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type RemoveBackgroundResult =
  | { success: true; data: { imageUrl: string } }
  | { success: false; error: { message: string } };

export type FalRemoveBackgroundCoreInput = {
  imageUrl: string;
};

export async function falRemoveBackgroundStep(
  input: FalRemoveBackgroundCoreInput,
): Promise<RemoveBackgroundResult> {
  "use step";
  const credentials = await fetchCredentials("fal");
  const apiKey = credentials.FAL_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "FAL_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  try {
    const response = await fetch(\`\${FAL_API_URL}/fal-ai/birefnet\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Key \${apiKey}\`,
      },
      body: JSON.stringify({
        image_url: input.imageUrl,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: { message: \`HTTP \${response.status}: \${errorText}\` },
      };
    }

    const queueResponse = (await response.json()) as FalQueueResponse;

    let result: FalRemoveBackgroundResponse;
    if (
      queueResponse.status === "IN_QUEUE" ||
      queueResponse.status === "IN_PROGRESS"
    ) {
      result = await pollForResult(
        queueResponse.status_url,
        queueResponse.response_url,
        apiKey,
      );
    } else {
      result = queueResponse as unknown as FalRemoveBackgroundResponse;
    }

    if (result.error) {
      return { success: false, error: { message: result.error } };
    }

    if (!result.image?.url) {
      return {
        success: false,
        error: { message: "No image returned from fal.ai" },
      };
    }

    return { success: true, data: { imageUrl: result.image.url } };
  } catch (error) {
    return {
      success: false,
      error: {
        message: \`Failed to remove background: \${getErrorMessage(error)}\`,
      },
    };
  }
}
`,

  "fal/image-to-image": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ImageToImageResult =
  | {
      success: true;
      data: { imageUrl: string; width?: number; height?: number };
    }
  | { success: false; error: { message: string } };

export type FalImageToImageCoreInput = {
  model: string;
  imageUrl: string;
  prompt: string;
  strength?: string;
};

export async function falImageToImageStep(
  input: FalImageToImageCoreInput,
): Promise<ImageToImageResult> {
  "use step";
  const credentials = await fetchCredentials("fal");
  const apiKey = credentials.FAL_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "FAL_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  try {
    const model = input.model || "fal-ai/flux/dev/image-to-image";
    const strength = Number.parseFloat(input.strength || "0.75");

    const response = await fetch(\`\${FAL_API_URL}/\${model}\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Key \${apiKey}\`,
      },
      body: JSON.stringify({
        image_url: input.imageUrl,
        prompt: input.prompt,
        strength,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: { message: \`HTTP \${response.status}: \${errorText}\` },
      };
    }

    const queueResponse = (await response.json()) as FalQueueResponse;

    let result: FalImageToImageResponse;
    if (
      queueResponse.status === "IN_QUEUE" ||
      queueResponse.status === "IN_PROGRESS"
    ) {
      result = await pollForResult(
        queueResponse.status_url,
        queueResponse.response_url,
        apiKey,
      );
    } else {
      result = queueResponse as unknown as FalImageToImageResponse;
    }

    if (result.error) {
      return { success: false, error: { message: result.error } };
    }

    // Handle both array format (images) and single image format
    const image = result.images?.[0] || result.image;
    if (!image?.url) {
      return {
        success: false,
        error: { message: "No image returned from fal.ai" },
      };
    }

    return {
      success: true,
      data: { imageUrl: image.url, width: image.width, height: image.height },
    };
  } catch (error) {
    return {
      success: false,
      error: {
        message: \`Failed to transform image: \${getErrorMessage(error)}\`,
      },
    };
  }
}
`,

  "firecrawl/scrape": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ScrapeResult = {
  markdown?: string;
  metadata?: Record<string, unknown>;
};

export type FirecrawlScrapeCoreInput = {
  url: string;
  formats?: ("markdown" | "html" | "rawHtml" | "links" | "screenshot")[];
};

export async function firecrawlScrapeStep(
  input: FirecrawlScrapeCoreInput,
): Promise<ScrapeResult> {
  "use step";
  const credentials = await fetchCredentials("firecrawl");
  const apiKey = credentials.FIRECRAWL_API_KEY;

  if (!apiKey) {
    throw new Error("Firecrawl API Key is not configured.");
  }

  try {
    const response = await fetch(\`\${FIRECRAWL_API_URL}/scrape\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        url: input.url,
        formats: input.formats || ["markdown"],
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(\`HTTP \${response.status}: \${errorText}\`);
    }

    const result = (await response.json()) as FirecrawlScrapeResponse;

    if (!result.success) {
      throw new Error(result.error || "Scrape failed");
    }

    return {
      markdown: result.data?.markdown,
      metadata: result.data?.metadata,
    };
  } catch (error) {
    throw new Error(\`Failed to scrape: \${getErrorMessage(error)}\`);
  }
}
`,

  "firecrawl/search": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SearchResult = {
  data?: unknown[];
};

export type FirecrawlSearchCoreInput = {
  query: string;
  limit?: number;
  scrapeOptions?: {
    formats?: ("markdown" | "html" | "rawHtml" | "links" | "screenshot")[];
  };
};

export async function firecrawlSearchStep(
  input: FirecrawlSearchCoreInput,
): Promise<SearchResult> {
  "use step";
  const credentials = await fetchCredentials("firecrawl");
  const apiKey = credentials.FIRECRAWL_API_KEY;

  if (!apiKey) {
    throw new Error("Firecrawl API Key is not configured.");
  }

  try {
    const response = await fetch(\`\${FIRECRAWL_API_URL}/search\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        query: input.query,
        limit: input.limit ? Number(input.limit) : undefined,
        scrapeOptions: input.scrapeOptions,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(\`HTTP \${response.status}: \${errorText}\`);
    }

    const result = (await response.json()) as FirecrawlSearchResponse;

    if (!result.success) {
      throw new Error(result.error || "Search failed");
    }

    return {
      data: result.data,
    };
  } catch (error) {
    throw new Error(\`Failed to search: \${getErrorMessage(error)}\`);
  }
}
`,

  "github/create-issue": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateIssueResult =
  | {
      success: true;
      id: number;
      number: number;
      title: string;
      url: string;
      state: string;
    }
  | { success: false; error: string };

export type CreateIssueCoreInput = {
  owner: string;
  repo: string;
  title: string;
  body?: string;
  labels?: string;
  assignees?: string;
};

export async function createIssueStep(
  input: CreateIssueCoreInput,
): Promise<CreateIssueResult> {
  "use step";
  const credentials = await fetchCredentials("github");
  const token = credentials.GITHUB_TOKEN;

  if (!token) {
    return {
      success: false,
      error:
        "GITHUB_TOKEN is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const body: Record<string, unknown> = {
      title: input.title,
    };

    if (input.body) {
      body.body = input.body;
    }

    const labels = parseCommaSeparated(input.labels);
    if (labels.length > 0) {
      body.labels = labels;
    }

    const assignees = parseCommaSeparated(input.assignees);
    if (assignees.length > 0) {
      body.assignees = assignees;
    }

    const response = await fetch(
      \`\${GITHUB_API_URL}/repos/\${input.owner}/\${input.repo}/issues\`,
      {
        method: "POST",
        headers: {
          Accept: "application/vnd.github+json",
          Authorization: \`Bearer \${token}\`,
          "X-GitHub-Api-Version": "2022-11-28",
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      },
    );

    if (!response.ok) {
      const errorData = (await response.json()) as { message?: string };
      return {
        success: false,
        error: errorData.message || \`HTTP \${response.status}\`,
      };
    }

    const issue = (await response.json()) as GitHubIssue;

    return {
      success: true,
      id: issue.id,
      number: issue.number,
      title: issue.title,
      url: issue.html_url,
      state: issue.state,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to create issue: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "github/list-issues": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ListIssuesResult =
  | {
      success: true;
      issues: Array<{
        id: number;
        number: number;
        title: string;
        url: string;
        state: string;
        body?: string;
        labels: string[];
        assignees: string[];
        createdAt: string;
        updatedAt: string;
      }>;
      count: number;
    }
  | { success: false; error: string };

export type ListIssuesCoreInput = {
  owner: string;
  repo: string;
  state?: string;
  labels?: string;
  assignee?: string;
  perPage?: number;
};

export async function listIssuesStep(
  input: ListIssuesCoreInput,
): Promise<ListIssuesResult> {
  "use step";
  const credentials = await fetchCredentials("github");
  const token = credentials.GITHUB_TOKEN;

  if (!token) {
    return {
      success: false,
      error:
        "GITHUB_TOKEN is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const params = new URLSearchParams();

    if (input.state && input.state !== "open") {
      params.set("state", input.state);
    }

    if (input.labels) {
      params.set("labels", input.labels);
    }

    if (input.assignee) {
      params.set("assignee", input.assignee);
    }

    if (input.perPage) {
      params.set("per_page", String(input.perPage));
    }

    const url = \`\${GITHUB_API_URL}/repos/\${input.owner}/\${input.repo}/issues\${
      params.toString() ? \`?\${params.toString()}\` : ""
    }\`;

    const response = await fetch(url, {
      method: "GET",
      headers: {
        Accept: "application/vnd.github+json",
        Authorization: \`Bearer \${token}\`,
        "X-GitHub-Api-Version": "2022-11-28",
      },
    });

    if (!response.ok) {
      const errorData = (await response.json()) as { message?: string };
      return {
        success: false,
        error: errorData.message || \`HTTP \${response.status}\`,
      };
    }

    const rawIssues = (await response.json()) as GitHubIssue[];

    const issues = rawIssues.map((issue) => ({
      id: issue.id,
      number: issue.number,
      title: issue.title,
      url: issue.html_url,
      state: issue.state,
      body: issue.body,
      labels: issue.labels.map((l) => l.name),
      assignees: issue.assignees.map((a) => a.login),
      createdAt: issue.created_at,
      updatedAt: issue.updated_at,
    }));

    return {
      success: true,
      issues,
      count: issues.length,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to list issues: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "github/get-issue": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GetIssueResult =
  | {
      success: true;
      id: number;
      number: number;
      title: string;
      url: string;
      state: string;
      body?: string;
      labels: string[];
      assignees: string[];
      author: string;
      createdAt: string;
      updatedAt: string;
      closedAt?: string;
      commentsCount: number;
    }
  | { success: false; error: string };

export type GetIssueCoreInput = {
  owner: string;
  repo: string;
  issueNumber: string;
};

export async function getIssueStep(
  input: GetIssueCoreInput,
): Promise<GetIssueResult> {
  "use step";
  const credentials = await fetchCredentials("github");
  const token = credentials.GITHUB_TOKEN;

  if (!token) {
    return {
      success: false,
      error:
        "GITHUB_TOKEN is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const issueNum = Number.parseInt(input.issueNumber, 10);
    if (Number.isNaN(issueNum)) {
      return {
        success: false,
        error: "Invalid issue number",
      };
    }

    const response = await fetch(
      \`\${GITHUB_API_URL}/repos/\${input.owner}/\${input.repo}/issues/\${issueNum}\`,
      {
        method: "GET",
        headers: {
          Accept: "application/vnd.github+json",
          Authorization: \`Bearer \${token}\`,
          "X-GitHub-Api-Version": "2022-11-28",
        },
      },
    );

    if (!response.ok) {
      const errorData = (await response.json()) as { message?: string };
      return {
        success: false,
        error: errorData.message || \`HTTP \${response.status}\`,
      };
    }

    const issue = (await response.json()) as GitHubIssue;

    return {
      success: true,
      id: issue.id,
      number: issue.number,
      title: issue.title,
      url: issue.html_url,
      state: issue.state,
      body: issue.body,
      labels: issue.labels.map((l) => l.name),
      assignees: issue.assignees.map((a) => a.login),
      author: issue.user.login,
      createdAt: issue.created_at,
      updatedAt: issue.updated_at,
      closedAt: issue.closed_at,
      commentsCount: issue.comments,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to get issue: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "github/update-issue": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type UpdateIssueResult =
  | {
      success: true;
      id: number;
      number: number;
      title: string;
      url: string;
      state: string;
    }
  | { success: false; error: string };

export type UpdateIssueCoreInput = {
  owner: string;
  repo: string;
  issueNumber: string;
  title?: string;
  body?: string;
  state?: string;
  labels?: string;
  assignees?: string;
};

export async function updateIssueStep(
  input: UpdateIssueCoreInput,
): Promise<UpdateIssueResult> {
  "use step";
  const credentials = await fetchCredentials("github");
  const token = credentials.GITHUB_TOKEN;

  if (!token) {
    return {
      success: false,
      error:
        "GITHUB_TOKEN is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const issueNum = Number.parseInt(input.issueNumber, 10);
    if (Number.isNaN(issueNum)) {
      return {
        success: false,
        error: "Invalid issue number",
      };
    }

    const body: Record<string, unknown> = {};

    if (input.title) {
      body.title = input.title;
    }

    if (input.body) {
      body.body = input.body;
    }

    if (input.state && input.state !== "") {
      body.state = input.state;
    }

    if (input.labels !== undefined) {
      const labels = parseCommaSeparated(input.labels);
      body.labels = labels;
    }

    if (input.assignees !== undefined) {
      const assignees = parseCommaSeparated(input.assignees);
      body.assignees = assignees;
    }

    if (Object.keys(body).length === 0) {
      return {
        success: false,
        error: "No fields to update. Please provide at least one field.",
      };
    }

    const response = await fetch(
      \`\${GITHUB_API_URL}/repos/\${input.owner}/\${input.repo}/issues/\${issueNum}\`,
      {
        method: "PATCH",
        headers: {
          Accept: "application/vnd.github+json",
          Authorization: \`Bearer \${token}\`,
          "X-GitHub-Api-Version": "2022-11-28",
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      },
    );

    if (!response.ok) {
      const errorData = (await response.json()) as { message?: string };
      return {
        success: false,
        error: errorData.message || \`HTTP \${response.status}\`,
      };
    }

    const issue = (await response.json()) as GitHubIssue;

    return {
      success: true,
      id: issue.id,
      number: issue.number,
      title: issue.title,
      url: issue.html_url,
      state: issue.state,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to update issue: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "linear/create-ticket": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateTicketResult =
  | { success: true; data: { id: string; url: string; title: string } }
  | { success: false; error: { message: string } };

export type CreateTicketCoreInput = {
  ticketTitle: string;
  ticketDescription: string;
};

export async function createTicketStep(
  input: CreateTicketCoreInput,
): Promise<CreateTicketResult> {
  "use step";
  const credentials = await fetchCredentials("linear");
  const apiKey = credentials.LINEAR_API_KEY;
  const teamId = credentials.LINEAR_TEAM_ID;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "LINEAR_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  try {
    let targetTeamId = teamId;

    if (!targetTeamId) {
      const teamsResult = await linearQuery<TeamsQueryResponse>(
        apiKey,
        \`query { teams { nodes { id name } } }\`,
      );

      if (teamsResult.errors?.length) {
        return {
          success: false,
          error: { message: teamsResult.errors[0].message },
        };
      }

      const firstTeam = teamsResult.data?.teams.nodes[0];
      if (!firstTeam) {
        return {
          success: false,
          error: { message: "No teams found in Linear workspace" },
        };
      }
      targetTeamId = firstTeam.id;
    }

    const createResult = await linearQuery<CreateIssueMutationResponse>(
      apiKey,
      \`mutation CreateIssue($title: String!, $description: String, $teamId: String!) {
        issueCreate(input: { title: $title, description: $description, teamId: $teamId }) {
          success
          issue {
            id
            title
            url
          }
        }
      }\`,
      {
        title: input.ticketTitle,
        description: input.ticketDescription,
        teamId: targetTeamId,
      },
    );

    if (createResult.errors?.length) {
      return {
        success: false,
        error: { message: createResult.errors[0].message },
      };
    }

    const issue = createResult.data?.issueCreate.issue;
    if (!issue) {
      return {
        success: false,
        error: { message: "Failed to create issue" },
      };
    }

    return {
      success: true,
      data: {
        id: issue.id,
        url: issue.url,
        title: issue.title,
      },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to create ticket: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "linear/find-issues": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type FindIssuesResult =
  | { success: true; data: { issues: LinearIssue[]; count: number } }
  | { success: false; error: { message: string } };

export type FindIssuesCoreInput = {
  linearAssigneeId?: string;
  linearTeamId?: string;
  linearStatus?: string;
  linearLabel?: string;
};

export async function findIssuesStep(
  input: FindIssuesCoreInput,
): Promise<FindIssuesResult> {
  "use step";
  const credentials = await fetchCredentials("linear");
  const apiKey = credentials.LINEAR_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "LINEAR_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  try {
    // Build filter object for Linear's GraphQL API
    const filter: Record<string, unknown> = {};

    if (input.linearAssigneeId) {
      filter.assignee = { id: { eq: input.linearAssigneeId } };
    }

    if (input.linearTeamId) {
      filter.team = { id: { eq: input.linearTeamId } };
    }

    if (input.linearStatus && input.linearStatus !== "any") {
      filter.state = { name: { eqIgnoreCase: input.linearStatus } };
    }

    if (input.linearLabel) {
      filter.labels = { name: { eqIgnoreCase: input.linearLabel } };
    }

    const result = await linearQuery<IssuesQueryResponse>(
      apiKey,
      \`query FindIssues($filter: IssueFilter) {
        issues(filter: $filter) {
          nodes {
            id
            title
            url
            priority
            assignee {
              id
            }
            state {
              name
            }
          }
        }
      }\`,
      { filter: Object.keys(filter).length > 0 ? filter : undefined },
    );

    if (result.errors?.length) {
      return {
        success: false,
        error: { message: result.errors[0].message },
      };
    }

    const mappedIssues: LinearIssue[] = (result.data?.issues.nodes || []).map(
      (issue) => ({
        id: issue.id,
        title: issue.title,
        url: issue.url,
        state: issue.state?.name || "Unknown",
        priority: issue.priority,
        assigneeId: issue.assignee?.id || undefined,
      }),
    );

    return {
      success: true,
      data: {
        issues: mappedIssues,
        count: mappedIssues.length,
      },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to find issues: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "perplexity/search": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SearchResult =
  | {
      success: true;
      data: { answer: string; citations: string[]; model: string };
    }
  | { success: false; error: { message: string } };

export type PerplexitySearchCoreInput = {
  query: string;
  searchFocus?: "internet" | "academic" | "news" | "youtube" | "reddit";
};

export async function perplexitySearchStep(
  input: PerplexitySearchCoreInput,
): Promise<SearchResult> {
  "use step";
  const credentials = await fetchCredentials("perplexity");
  const apiKey = credentials.PERPLEXITY_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: { message: "Perplexity API Key is not configured." },
    };
  }

  try {
    const response = await fetch(PERPLEXITY_API_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        model: "sonar",
        messages: [
          {
            role: "system",
            content:
              "You are a helpful search assistant. Provide concise, accurate answers with relevant sources.",
          },
          {
            role: "user",
            content: input.query,
          },
        ],
        search_domain_filter: getSearchDomains(input.searchFocus),
        return_citations: true,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: { message: \`HTTP \${response.status}: \${errorText}\` },
      };
    }

    const result = (await response.json()) as PerplexityResponse;

    const answer = result.choices[0]?.message?.content || "";
    const citations = (result.citations || []).map((c) =>
      typeof c === "string" ? c : c.url,
    );

    return {
      success: true,
      data: { answer, citations, model: result.model },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to search: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "perplexity/ask": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type AskResult =
  | {
      success: true;
      data: { answer: string; citations: string[]; model: string };
    }
  | { success: false; error: { message: string } };

export type PerplexityAskCoreInput = {
  question: string;
  systemPrompt?: string;
  model?: string;
};

export async function perplexityAskStep(
  input: PerplexityAskCoreInput,
): Promise<AskResult> {
  "use step";
  const credentials = await fetchCredentials("perplexity");
  const apiKey = credentials.PERPLEXITY_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: { message: "Perplexity API Key is not configured." },
    };
  }

  try {
    const messages: PerplexityMessage[] = [];

    if (input.systemPrompt) {
      messages.push({
        role: "system",
        content: input.systemPrompt,
      });
    } else {
      messages.push({
        role: "system",
        content:
          "You are a helpful AI assistant. Provide accurate, well-researched answers with citations when available.",
      });
    }

    messages.push({
      role: "user",
      content: input.question,
    });

    const response = await fetch(PERPLEXITY_API_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        model: input.model || "sonar",
        messages,
        return_citations: true,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: { message: \`HTTP \${response.status}: \${errorText}\` },
      };
    }

    const result = (await response.json()) as PerplexityResponse;

    const answer = result.choices[0]?.message?.content || "";
    const citations = (result.citations || []).map((c) =>
      typeof c === "string" ? c : c.url,
    );

    return {
      success: true,
      data: { answer, citations, model: result.model },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to ask: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "perplexity/research": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ResearchResult =
  | {
      success: true;
      data: { report: string; citations: string[]; model: string };
    }
  | { success: false; error: { message: string } };

export type PerplexityResearchCoreInput = {
  topic: string;
  depth?: "brief" | "detailed" | "comprehensive";
};

export async function perplexityResearchStep(
  input: PerplexityResearchCoreInput,
): Promise<ResearchResult> {
  "use step";
  const credentials = await fetchCredentials("perplexity");
  const apiKey = credentials.PERPLEXITY_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: { message: "Perplexity API Key is not configured." },
    };
  }

  const depthInstructions = getDepthInstructions(input.depth);

  try {
    const response = await fetch(PERPLEXITY_API_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        model: "sonar-pro",
        messages: [
          {
            role: "system",
            content: \`You are an expert research analyst. Your task is to provide \${depthInstructions} research on the given topic. Structure your response with clear sections, include relevant data and statistics when available, and cite your sources. Focus on accuracy, comprehensiveness, and actionable insights.\`,
          },
          {
            role: "user",
            content: \`Research the following topic thoroughly: \${input.topic}\`,
          },
        ],
        return_citations: true,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: { message: \`HTTP \${response.status}: \${errorText}\` },
      };
    }

    const result = (await response.json()) as PerplexityResponse;

    const report = result.choices[0]?.message?.content || "";
    const citations = (result.citations || []).map((c) =>
      typeof c === "string" ? c : c.url,
    );

    return {
      success: true,
      data: { report, citations, model: result.model },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to research: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "resend/send-email": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SendEmailResult =
  | { success: true; data: { id: string } }
  | { success: false; error: { message: string } };

export type SendEmailCoreInput = {
  emailFrom?: string;
  emailTo: string;
  emailSubject: string;
  emailBody: string;
  emailCc?: string;
  emailBcc?: string;
  emailReplyTo?: string;
  emailScheduledAt?: string;
  emailTopicId?: string;
  idempotencyKey?: string;
};

export async function sendEmailStep(
  input: SendEmailCoreInput,
): Promise<SendEmailResult> {
  "use step";
  const credentials = await fetchCredentials("resend");
  const apiKey = credentials.RESEND_API_KEY;
  const fromEmail = credentials.RESEND_FROM_EMAIL;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "RESEND_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  const senderEmail = input.emailFrom || fromEmail;

  if (!senderEmail) {
    return {
      success: false,
      error: {
        message:
          "No sender is configured. Please add it in the action or in Project Integrations.",
      },
    };
  }

  try {
    const headers: Record<string, string> = {
      Authorization: \`Bearer \${apiKey}\`,
      "Content-Type": "application/json",
    };

    if (input.idempotencyKey) {
      headers["Idempotency-Key"] = input.idempotencyKey;
    }

    const response = await fetch(\`\${RESEND_API_URL}/emails\`, {
      method: "POST",
      headers,
      body: JSON.stringify({
        from: senderEmail,
        to: input.emailTo,
        subject: input.emailSubject,
        text: input.emailBody,
        ...(input.emailCc && { cc: input.emailCc }),
        ...(input.emailBcc && { bcc: input.emailBcc }),
        ...(input.emailReplyTo && { reply_to: input.emailReplyTo }),
        ...(input.emailScheduledAt && { scheduled_at: input.emailScheduledAt }),
      }),
    });

    if (!response.ok) {
      const errorData = (await response.json()) as ResendErrorResponse;
      return {
        success: false,
        error: {
          message:
            errorData.message ||
            \`HTTP \${response.status}: Failed to send email\`,
        },
      };
    }

    const data = (await response.json()) as ResendEmailResponse;
    return { success: true, data: { id: data.id } };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: { message: \`Failed to send email: \${errorMessage}\` },
    };
  }
}
`,

  "slack/send-message": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SendSlackMessageResult =
  | { success: true; ts: string; channel: string }
  | { success: false; error: string };

export type SendSlackMessageCoreInput = {
  slackChannel: string;
  slackMessage: string;
};

export async function sendSlackMessageStep(
  input: SendSlackMessageCoreInput,
): Promise<SendSlackMessageResult> {
  "use step";
  const credentials = await fetchCredentials("slack");
  const apiKey = credentials.SLACK_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "SLACK_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const response = await fetch(\`\${SLACK_API_URL}/chat.postMessage\`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        channel: input.slackChannel,
        text: input.slackMessage,
      }),
    });

    if (!response.ok) {
      return {
        success: false,
        error: \`HTTP \${response.status}: Failed to send Slack message\`,
      };
    }

    const result = (await response.json()) as SlackPostMessageResponse;

    if (!result.ok) {
      return {
        success: false,
        error: result.error || "Failed to send Slack message",
      };
    }

    return {
      success: true,
      ts: result.ts || "",
      channel: result.channel || "",
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to send Slack message: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "stripe/create-customer": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateCustomerResult =
  | { success: true; id: string; email: string }
  | { success: false; error: string };

export type CreateCustomerCoreInput = {
  email: string;
  name?: string;
  phone?: string;
  description?: string;
  metadata?: string;
};

export async function createCustomerStep(
  input: CreateCustomerCoreInput,
): Promise<CreateCustomerResult> {
  "use step";
  const credentials = await fetchCredentials("stripe");
  const apiKey = credentials.STRIPE_SECRET_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "STRIPE_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const params = new URLSearchParams();
    params.append("email", input.email);

    if (input.name) {
      params.append("name", input.name);
    }
    if (input.phone) {
      params.append("phone", input.phone);
    }
    if (input.description) {
      params.append("description", input.description);
    }
    if (input.metadata) {
      try {
        const metadataObj = JSON.parse(input.metadata) as Record<
          string,
          string
        >;
        for (const [key, value] of Object.entries(metadataObj)) {
          params.append(\`metadata[\${key}]\`, String(value));
        }
      } catch {
        return {
          success: false,
          error: "Invalid metadata JSON format",
        };
      }
    }

    const response = await fetch(\`\${STRIPE_API_URL}/customers\`, {
      method: "POST",
      headers: {
        Authorization: \`Bearer \${apiKey}\`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: params.toString(),
    });

    if (!response.ok) {
      const errorData = (await response.json()) as StripeErrorResponse;
      return {
        success: false,
        error:
          errorData.error?.message ||
          \`HTTP \${response.status}: Failed to create customer\`,
      };
    }

    const data = (await response.json()) as StripeCustomerResponse;
    return { success: true, id: data.id, email: data.email };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to create customer: \${message}\`,
    };
  }
}
`,

  "stripe/get-customer": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GetCustomerResult =
  | {
      success: true;
      id: string;
      email: string;
      name: string | null;
      created: number;
    }
  | { success: false; error: string };

export type GetCustomerCoreInput = {
  customerId?: string;
  email?: string;
};

export async function getCustomerStep(
  input: GetCustomerCoreInput,
): Promise<GetCustomerResult> {
  "use step";
  const credentials = await fetchCredentials("stripe");
  const apiKey = credentials.STRIPE_SECRET_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "STRIPE_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  if (!input.customerId && !input.email) {
    return {
      success: false,
      error: "Either Customer ID or Email is required",
    };
  }

  try {
    let customer: StripeCustomerResponse | null = null;

    if (input.customerId) {
      // Direct lookup by ID
      const response = await fetch(
        \`\${STRIPE_API_URL}/customers/\${input.customerId}\`,
        {
          method: "GET",
          headers: {
            Authorization: \`Bearer \${apiKey}\`,
          },
        },
      );

      if (!response.ok) {
        const errorData = (await response.json()) as StripeErrorResponse;
        return {
          success: false,
          error:
            errorData.error?.message ||
            \`HTTP \${response.status}: Failed to get customer\`,
        };
      }

      customer = (await response.json()) as StripeCustomerResponse;
    } else if (input.email) {
      // Search by email
      const params = new URLSearchParams();
      params.append("email", input.email);
      params.append("limit", "1");

      const response = await fetch(
        \`\${STRIPE_API_URL}/customers?\${params.toString()}\`,
        {
          method: "GET",
          headers: {
            Authorization: \`Bearer \${apiKey}\`,
          },
        },
      );

      if (!response.ok) {
        const errorData = (await response.json()) as StripeErrorResponse;
        return {
          success: false,
          error:
            errorData.error?.message ||
            \`HTTP \${response.status}: Failed to search customers\`,
        };
      }

      const data = (await response.json()) as StripeCustomerListResponse;
      if (data.data.length === 0) {
        return {
          success: false,
          error: \`No customer found with email: \${input.email}\`,
        };
      }
      customer = data.data[0];
    }

    if (!customer) {
      return {
        success: false,
        error: "Customer not found",
      };
    }

    return {
      success: true,
      id: customer.id,
      email: customer.email,
      name: customer.name,
      created: customer.created,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to get customer: \${message}\`,
    };
  }
}
`,

  "stripe/create-invoice": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateInvoiceResult =
  | {
      success: true;
      id: string;
      number: string | null;
      hostedInvoiceUrl: string | null;
      status: string;
    }
  | { success: false; error: string };

export type CreateInvoiceCoreInput = {
  customerId: string;
  description?: string;
  lineItems: string;
  daysUntilDue?: number;
  autoAdvance?: string;
  collectionMethod?: "send_invoice" | "charge_automatically";
  metadata?: string;
};

export async function createInvoiceStep(
  input: CreateInvoiceCoreInput,
): Promise<CreateInvoiceResult> {
  "use step";
  const credentials = await fetchCredentials("stripe");
  const apiKey = credentials.STRIPE_SECRET_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "STRIPE_SECRET_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  let lineItems: LineItem[];
  try {
    lineItems = JSON.parse(input.lineItems) as LineItem[];
    if (!Array.isArray(lineItems) || lineItems.length === 0) {
      return {
        success: false,
        error: "Line items must be a non-empty JSON array",
      };
    }
  } catch {
    return {
      success: false,
      error:
        'Invalid line items JSON format. Expected: [{"description": "Item", "amount": 1000, "quantity": 1}]',
    };
  }

  try {
    // Step 1: Create the invoice
    const invoiceParams = new URLSearchParams();
    invoiceParams.append("customer", input.customerId);
    invoiceParams.append(
      "collection_method",
      input.collectionMethod || "send_invoice",
    );
    invoiceParams.append("days_until_due", String(input.daysUntilDue || 30));
    invoiceParams.append(
      "auto_advance",
      input.autoAdvance === "false" ? "false" : "true",
    );

    if (input.description) {
      invoiceParams.append("description", input.description);
    }
    if (input.metadata) {
      try {
        const metadataObj = JSON.parse(input.metadata) as Record<
          string,
          string
        >;
        for (const [key, value] of Object.entries(metadataObj)) {
          invoiceParams.append(\`metadata[\${key}]\`, String(value));
        }
      } catch {
        return {
          success: false,
          error: "Invalid metadata JSON format",
        };
      }
    }

    const invoiceResponse = await fetch(\`\${STRIPE_API_URL}/invoices\`, {
      method: "POST",
      headers: {
        Authorization: \`Bearer \${apiKey}\`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: invoiceParams.toString(),
    });

    if (!invoiceResponse.ok) {
      const errorData = (await invoiceResponse.json()) as StripeErrorResponse;
      return {
        success: false,
        error:
          errorData.error?.message ||
          \`HTTP \${invoiceResponse.status}: Failed to create invoice\`,
      };
    }

    const invoice = (await invoiceResponse.json()) as StripeInvoiceResponse;

    // Step 2: Add line items
    for (const item of lineItems) {
      const itemParams = new URLSearchParams();
      itemParams.append("invoice", invoice.id);
      itemParams.append("description", item.description);
      itemParams.append("quantity", String(item.quantity || 1));
      itemParams.append("unit_amount", String(item.amount));
      itemParams.append("currency", "usd");

      const itemResponse = await fetch(\`\${STRIPE_API_URL}/invoiceitems\`, {
        method: "POST",
        headers: {
          Authorization: \`Bearer \${apiKey}\`,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: itemParams.toString(),
      });

      if (!itemResponse.ok) {
        const errorData = (await itemResponse.json()) as StripeErrorResponse;
        return {
          success: false,
          error:
            errorData.error?.message ||
            \`HTTP \${itemResponse.status}: Failed to add line item\`,
        };
      }
    }

    // Step 3: Finalize invoice if auto_advance is true
    let finalInvoice = invoice;
    if (input.autoAdvance !== "false") {
      const finalizeResponse = await fetch(
        \`\${STRIPE_API_URL}/invoices/\${invoice.id}/finalize\`,
        {
          method: "POST",
          headers: {
            Authorization: \`Bearer \${apiKey}\`,
            "Content-Type": "application/x-www-form-urlencoded",
          },
        },
      );

      if (!finalizeResponse.ok) {
        const errorData =
          (await finalizeResponse.json()) as StripeErrorResponse;
        return {
          success: false,
          error:
            errorData.error?.message ||
            \`HTTP \${finalizeResponse.status}: Failed to finalize invoice\`,
        };
      }

      finalInvoice = (await finalizeResponse.json()) as StripeInvoiceResponse;
    }

    return {
      success: true,
      id: finalInvoice.id,
      number: finalInvoice.number,
      hostedInvoiceUrl: finalInvoice.hosted_invoice_url,
      status: finalInvoice.status,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: \`Failed to create invoice: \${message}\`,
    };
  }
}
`,

  "superagent/guard": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GuardResult = {
  classification: GuardClassification;
  violationTypes: string[];
  cweCodes: string[];
  reasoning?: string;
};

export type SuperagentGuardCoreInput = {
  text: string;
};

export async function superagentGuardStep(
  input: SuperagentGuardCoreInput,
): Promise<GuardResult> {
  "use step";
  const credentials = await fetchCredentials("superagent");
  const apiKey = credentials.SUPERAGENT_API_KEY;

  if (!apiKey) {
    throw new Error("Superagent API Key is not configured.");
  }

  try {
    const response = await fetch("https://app.superagent.sh/api/guard", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify({
        text: input.text,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Guard API error: \${error}\`);
    }

    const data = await response.json();
    const choice = data.choices?.[0];
    const content = choice?.message?.content;

    if (!content || typeof content !== "object") {
      throw new Error(
        "Invalid Guard API response: missing or invalid content structure",
      );
    }

    const classification = content.classification;
    if (
      !classification ||
      (classification !== "pass" && classification !== "block")
    ) {
      throw new Error(
        \`Invalid Guard API response: missing or invalid classification (received: \${JSON.stringify(classification)})\`,
      );
    }

    return {
      classification,
      violationTypes: content?.violation_types || [],
      cweCodes: content?.cwe_codes || [],
      reasoning: choice?.message?.reasoning,
    };
  } catch (error) {
    throw new Error(\`Failed to analyze text: \${getErrorMessage(error)}\`);
  }
}
`,

  "superagent/redact": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type RedactResult = {
  redactedText: string;
  reasoning?: string;
};

export type SuperagentRedactCoreInput = {
  text: string;
  entities?: string[] | string;
};

export async function superagentRedactStep(
  input: SuperagentRedactCoreInput,
): Promise<RedactResult> {
  "use step";
  const credentials = await fetchCredentials("superagent");
  const apiKey = credentials.SUPERAGENT_API_KEY;

  if (!apiKey) {
    throw new Error("Superagent API Key is not configured.");
  }

  try {
    const body: { text: string; entities?: string[] } = {
      text: input.text,
    };

    if (input.entities) {
      let entitiesArray: string[];

      if (typeof input.entities === "string") {
        entitiesArray = input.entities.split(",").map((e) => e.trim());
      } else if (Array.isArray(input.entities)) {
        entitiesArray = input.entities.map((e) => String(e).trim());
      } else {
        entitiesArray = [];
      }

      const validEntities = entitiesArray.filter((e) => e.length > 0);

      if (validEntities.length > 0) {
        body.entities = validEntities;
      }
    }

    const response = await fetch("https://app.superagent.sh/api/redact", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Redact API error: \${error}\`);
    }

    const data = await response.json();
    const choice = data.choices?.[0];

    return {
      redactedText: choice?.message?.content || input.text,
      reasoning: choice?.message?.reasoning,
    };
  } catch (error) {
    throw new Error(\`Failed to redact text: \${getErrorMessage(error)}\`);
  }
}
`,

  "tixr/import-venue-events": `import {
  algoliaClient,
  findClosestArtists,
  getAlgoliaIndexName,
  hasPerformanceForEvent,
  uploadImage,
} from "@beatplatform/core";
import { Channel, Database, FileDirectory, db } from "@beatplatform/db";
import { GroupEventsResponse, Tixr } from "@beatplatform/tixr";
import { DateTime } from "luxon";
import slugify from "slugify";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ImportVenueEventsResult =
  | { success: true; imported: number; skipped: number; logs: string[] }
  | { success: false; error: string; logs: string[] };

// Core input fields from Database step
export type ImportVenueEventsCoreInput = {
  events: GroupEventsResponse;
};

export async function importVenueEventsStep(
  input: ImportVenueEventsCoreInput,
): Promise<ImportVenueEventsResult> {
  "use step";
  const credentials = await fetchCredentials("tixr-events-importer");
  const dataDomeCookie = credentials.TIXR_DATADOME_COOKIE;

  if (!dataDomeCookie) {
    return {
      success: false,
      error:
        "TIXR_DATADOME_COOKIE is not configured. Please add it in Project Integrations.",
      logs: [],
    };
  }

  const logs: string[] = [];
  let imported = 0;
  let skipped = 0;

  try {
    const tixr = new Tixr(dataDomeCookie);
    await tixr.refreshCookie();

    for (const { id, name } of input.events) {
      // Check if event already exists
      const existingEvent = await getEventIfExists(
        slugify(name, { lower: true, strict: true }),
        String(id),
        Channel.TIXR,
      );
      if (existingEvent) {
        logs.push(\`[skip] "\${name}" already exists\`);
        skipped++;
        continue;
      }

      // Get more data for single event
      const { data: eventData } = await tixr.getEvent(id);

      let image: { id: string; url: string } | undefined = undefined;
      const socialMap = new Map<string, Database["SocialLink"]>();
      const performanceMap = new Map<string, Database["Performance"]>();

      try {
        image = await uploadImage(
          eventData?.mobileImageUrl,
          FileDirectory.EVENTS,
        );
      } catch {
        logs.push(\`[warn] "\${name}" image could not be retrieved\`);
      }

      // Create new Event instance
      const event = {
        id: crypto.randomUUID(),
        name: eventData.name,
        slug: slugify(eventData.name, { lower: true, strict: true }),
        description: eventData.description,
        startAt: DateTime.fromMillis(eventData.startDate, {
          zone: eventData.venue.timezone,
        }).toISO(),
        endAt: DateTime.fromMillis(eventData.endDate, {
          zone: eventData.venue.timezone,
        }).toISO(),
        imageId: image?.id,
      } as Database["Event"];

      // Add Tixr channel
      socialMap.set(Channel.TIXR, {
        id: crypto.randomUUID(),
        eventId: event.id,
        channel: Channel.TIXR,
        channelId: String(id),
        link: eventData.shortUrl,
        synchronizable: false,
      });

      // Add venue reference
      if (eventData?.group?.id) {
        const existingVenue = await db
          .selectFrom("SocialLink")
          .innerJoin("Venue", "Venue.id", "SocialLink.venueId")
          .selectAll(["Venue"])
          .where("SocialLink.channel", "=", Channel.TIXR)
          .where("SocialLink.channelId", "=", String(eventData.group.id))
          .executeTakeFirst();
        if (existingVenue) event.venueId = existingVenue.id;
      }

      // Add event's performances from lineup artists
      if (eventData.lineups?.length) {
        for (const { acts } of eventData.lineups) {
          for (const { artist } of acts) {
            await createPerformanceFromName(
              event,
              performanceMap,
              artist.name,
              logs,
            );
          }
        }
      }
      // Fallback: extract artist names from the event title
      else {
        if (!hasPerformanceForEvent(performanceMap, event.id)) {
          const closestArtists = await findClosestArtists(eventData.name);
          for (const artist of closestArtists) {
            await createPerformanceFromName(
              event,
              performanceMap,
              artist,
              logs,
            );
          }
        }
      }

      // Skip events with no performances (not electronic music)
      if (!performanceMap.size) {
        logs.push(\`[skip] "\${name}" has no matching performances\`);
        skipped++;
        continue;
      }

      // Add event to Algolia
      const { objectID } = await algoliaClient.saveObject({
        indexName: getAlgoliaIndexName("events", "production"),
        body: {
          id: event.id,
          slug: event.slug,
          name: event.name,
          country: eventData?.venue?.address?.countryCodeAlpha2,
          image: image?.url,
        },
      });

      // Add Event in DB
      await db
        .insertInto("Event")
        .values({ ...event, algoliaObjectID: objectID })
        .executeTakeFirstOrThrow();

      // Add social links
      await db
        .insertInto("SocialLink")
        .values(
          Array.from(socialMap.values()).filter(
            (s) => s.link != null && s.link.trim() !== "",
          ),
        )
        .execute();

      // Add performances
      await db
        .insertInto("Performance")
        .values(Array.from(performanceMap.values()))
        .execute();

      // Add ticket link
      await db
        .insertInto("Ticket")
        .values({
          id: crypto.randomUUID(),
          link: eventData.shortUrl,
          eventId: event.id,
          provider: "tixr.com",
        })
        .executeTakeFirstOrThrow();

      logs.push(\`[imported] "\${event.name}"\`);
      imported++;
    }

    return { success: true, imported, skipped, logs };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to import venue events: \${getErrorMessage(error)}\`,
      logs,
    };
  }
}
`,

  "tixr/get-venue-events": `import type { Event } from "@beatplatform/tixr";
import { Tixr } from "@beatplatform/tixr";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GetVenueEventsResult =
  | { success: true; events: Event[] }
  | { success: false; error: string };

export type GetVenueEventsCoreInput = {
  venueId: string;
  page?: string;
  startDate?: string;
  endDate?: string;
};

export async function getVenueEventsStep(
  input: GetVenueEventsCoreInput,
): Promise<GetVenueEventsResult> {
  "use step";
  const credentials = await fetchCredentials("tixr-events-importer");
  const dataDomeCookie = credentials.TIXR_DATADOME_COOKIE;

  if (!dataDomeCookie) {
    return {
      success: false,
      error:
        "TIXR_DATADOME_COOKIE is not configured. Please add it in Project Integrations.",
    };
  }

  const groupId = Number(input.venueId);
  if (Number.isNaN(groupId)) {
    return {
      success: false,
      error: \`Invalid venueId: "\${input.venueId}". Must be a numeric Tixr group ID.\`,
    };
  }

  try {
    const tixr = new Tixr(dataDomeCookie);
    await tixr.refreshCookie();

    const page = input.page ? Number(input.page) : undefined;
    const response = await tixr.getGroupEvents(
      groupId,
      page,
      input.startDate,
      input.endDate,
    );

    return { success: true, events: response.data };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to get venue events: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "v0/create-chat": `import { createClient, type ChatsCreateResponse } from "v0-sdk";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type CreateChatResult =
  | { success: true; chatId: string; url: string; demoUrl?: string }
  | { success: false; error: string };

export type CreateChatCoreInput = {
  message: string;
  system?: string;
};

export async function createChatStep(
  input: CreateChatCoreInput,
): Promise<CreateChatResult> {
  "use step";
  const credentials = await fetchCredentials("v0");
  const apiKey = credentials.V0_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "V0_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const client = createClient({ apiKey });

    const result = (await client.chats.create({
      message: input.message,
      system: input.system,
    })) as ChatsCreateResponse;

    return {
      success: true,
      chatId: result.id,
      url: result.webUrl,
      demoUrl: result.latestVersion?.demoUrl,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to create chat: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "v0/send-message": `import { createClient, type ChatsSendMessageResponse } from "v0-sdk";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SendMessageResult =
  | { success: true; chatId: string; demoUrl?: string }
  | { success: false; error: string };

export type SendMessageCoreInput = {
  chatId: string;
  message: string;
};

export async function sendMessageStep(
  input: SendMessageCoreInput,
): Promise<SendMessageResult> {
  "use step";
  const credentials = await fetchCredentials("v0");
  const apiKey = credentials.V0_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error:
        "V0_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  try {
    const client = createClient({ apiKey });

    const result = (await client.chats.sendMessage({
      chatId: input.chatId,
      message: input.message,
    })) as ChatsSendMessageResponse;

    return {
      success: true,
      chatId: result.id,
      demoUrl: result.latestVersion?.demoUrl,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to send message: \${getErrorMessage(error)}\`,
    };
  }
}
`,

  "webflow/list-sites": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type ListSitesResult =
  | { success: true; data: { sites: SiteData[]; count: number } }
  | { success: false; error: { message: string } };

export type ListSitesCoreInput = Record<string, never>;

export async function listSitesStep(
  input: ListSitesCoreInput,
): Promise<ListSitesResult> {
  "use step";
  const credentials = await fetchCredentials("webflow");
  const apiKey = credentials.WEBFLOW_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "WEBFLOW_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  try {
    const response = await fetch(\`\${WEBFLOW_API_URL}/sites\`, {
      method: "GET",
      headers: {
        Accept: "application/json",
        Authorization: \`Bearer \${apiKey}\`,
      },
    });

    if (!response.ok) {
      const errorData = (await response.json()) as { message?: string };
      return {
        success: false,
        error: { message: errorData.message || \`HTTP \${response.status}\` },
      };
    }

    const data = (await response.json()) as { sites: WebflowSite[] };

    const sites = data.sites.map((site) => ({
      id: site.id,
      displayName: site.displayName,
      shortName: site.shortName,
      previewUrl: site.previewUrl,
      lastPublished: site.lastPublished,
      lastUpdated: site.lastUpdated,
      customDomains: site.customDomains?.map((d) => d.url) || [],
    }));

    return {
      success: true,
      data: { sites, count: sites.length },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to list sites: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "webflow/get-site": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type GetSiteResult =
  | { success: true; data: GetSiteData }
  | { success: false; error: { message: string } };

export type GetSiteCoreInput = {
  siteId: string;
};

export async function getSiteStep(
  input: GetSiteCoreInput,
): Promise<GetSiteResult> {
  "use step";
  const credentials = await fetchCredentials("webflow");
  const apiKey = credentials.WEBFLOW_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "WEBFLOW_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  if (!input.siteId) {
    return {
      success: false,
      error: { message: "Site ID is required" },
    };
  }

  try {
    const response = await fetch(
      \`\${WEBFLOW_API_URL}/sites/\${encodeURIComponent(input.siteId)}\`,
      {
        method: "GET",
        headers: {
          Accept: "application/json",
          Authorization: \`Bearer \${apiKey}\`,
        },
      },
    );

    if (!response.ok) {
      const errorData = (await response.json()) as { message?: string };
      return {
        success: false,
        error: { message: errorData.message || \`HTTP \${response.status}\` },
      };
    }

    const site = (await response.json()) as WebflowSiteResponse;

    return {
      success: true,
      data: {
        id: site.id,
        displayName: site.displayName,
        shortName: site.shortName,
        previewUrl: site.previewUrl,
        lastPublished: site.lastPublished,
        lastUpdated: site.lastUpdated,
        timeZone: site.timeZone,
        customDomains: site.customDomains || [],
      },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to get site: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "webflow/publish-site": `import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type PublishSiteResult =
  | {
      success: true;
      data: { publishedDomains: string[]; publishedToSubdomain: boolean };
    }
  | { success: false; error: { message: string } };

export type PublishSiteCoreInput = {
  siteId: string;
  publishToWebflowSubdomain?: string;
  customDomainIds?: string;
};

export async function publishSiteStep(
  input: PublishSiteCoreInput,
): Promise<PublishSiteResult> {
  "use step";
  const credentials = await fetchCredentials("webflow");
  const apiKey = credentials.WEBFLOW_API_KEY;

  if (!apiKey) {
    return {
      success: false,
      error: {
        message:
          "WEBFLOW_API_KEY is not configured. Please add it in Project Integrations.",
      },
    };
  }

  if (!input.siteId) {
    return {
      success: false,
      error: { message: "Site ID is required" },
    };
  }

  try {
    const body: {
      publishToWebflowSubdomain?: boolean;
      customDomains?: string[];
    } = {};

    // Parse custom domain IDs if provided
    const customDomains = input.customDomainIds
      ? input.customDomainIds
          .split(",")
          .map((id) => id.trim())
          .filter(Boolean)
      : [];

    if (customDomains.length > 0) {
      body.customDomains = customDomains;
    }

    // Default to publishing to subdomain if no custom domains specified
    // or if explicitly set to true
    const publishToSubdomain =
      input.publishToWebflowSubdomain === "false" ? false : true;

    if (publishToSubdomain || customDomains.length === 0) {
      body.publishToWebflowSubdomain = true;
    } else {
      body.publishToWebflowSubdomain = false;
    }

    const response = await fetch(
      \`\${WEBFLOW_API_URL}/sites/\${encodeURIComponent(input.siteId)}/publish\`,
      {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: \`Bearer \${apiKey}\`,
        },
        body: JSON.stringify(body),
      },
    );

    if (!response.ok) {
      const errorData = (await response.json()) as { message?: string };
      return {
        success: false,
        error: { message: errorData.message || \`HTTP \${response.status}\` },
      };
    }

    const result = (await response.json()) as PublishResponse;

    return {
      success: true,
      data: {
        publishedDomains: result.customDomains?.map((d) => d.url) || [],
        publishedToSubdomain: result.publishToWebflowSubdomain ?? false,
      },
    };
  } catch (error) {
    return {
      success: false,
      error: { message: \`Failed to publish site: \${getErrorMessage(error)}\` },
    };
  }
}
`,

  "youtube/sync-playlist": `import { getVideosFromPlaylist } from "@beatplatform/core";
import { db, VideoType } from "@beatplatform/db";
import { youtube_v3 } from "@googleapis/youtube";
import { OAuth2Client } from "google-auth-library";
import { fetchCredentials } from "./lib/credential-helper";

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  return String(error);
}

type SyncPlaylistResult =
  | { success: true; editionId: string; videosCount: number; skipped?: boolean }
  | { success: false; error: string };

export type SyncPlaylistCoreInput = {
  /** Current item from Loop step */
  currentItem: PlaylistItem;
};

export async function syncPlaylistStep(
  input: SyncPlaylistCoreInput,
): Promise<SyncPlaylistResult> {
  "use step";
  const credentials = await fetchCredentials("youtube");
  const apiKey = credentials.YOUTUBE_API_KEY;
  if (!apiKey) {
    return {
      success: false,
      error:
        "YOUTUBE_API_KEY is not configured. Please add it in Project Integrations.",
    };
  }

  const item = input.currentItem;
  if (!item) {
    return {
      success: false,
      error:
        "No currentItem provided. This step should be used after a Loop node.",
    };
  }

  if (!item.youtubePlaylistId) {
    return {
      success: false,
      error: "No YouTube playlist ID in currentItem",
    };
  }

  if (!item.id) {
    return {
      success: false,
      error: "No edition ID in currentItem",
    };
  }

  try {
    const oauth2Client = new OAuth2Client({
      clientId: credentials.GOOGLE_CLIENT_ID,
      clientSecret: credentials.GOOGLE_CLIENT_SECRET,
      apiKey,
    });
    const youtube = new youtube_v3.Youtube({ auth: oauth2Client });

    const videos = await getVideosFromPlaylist(
      youtube,
      item.youtubePlaylistId,
      VideoType.RELIVE,
      undefined,
      undefined,
      item.id,
    );

    if (videos.size === 0) {
      return {
        success: true,
        editionId: item.id,
        videosCount: 0,
        skipped: true,
      };
    }

    // Insert videos into database
    await db.insertInto("Video").values(Array.from(videos.values())).execute();

    // Update edition timestamp
    await db
      .updateTable("Edition")
      .set({
        youtubePlaylistId: item.youtubePlaylistId,
        updatedAt: new Date().toISOString(),
      })
      .where("Edition.id", "=", item.id)
      .execute();

    return {
      success: true,
      editionId: item.id,
      videosCount: videos.size,
    };
  } catch (error) {
    return {
      success: false,
      error: \`Failed to sync playlist: \${getErrorMessage(error)}\`,
    };
  }
}
`,
};

/**
 * Get the auto-generated codegen template for an action
 */
export function getAutoGeneratedTemplate(actionId: string): string | undefined {
  return AUTO_GENERATED_TEMPLATES[actionId];
}
